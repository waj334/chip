//go:build arm && cortexm && armv7m && armv7em && thumb && (stm32h747ag || stm32h747ig || stm32h747bg || stm32h747xg || stm32h747zi || stm32h747ai || stm32h747ii || stm32h747bi || stm32h747xi || stm32h757zi || stm32h757ai || stm32h757ii || stm32h757bi || stm32h757xi)

package vrefbuf

import (
	"unsafe"
	"volatile"
)

var (
	Vrefbuf = (*_vrefbuf)(unsafe.Pointer(uintptr(0x58003c00)))
)

type _vrefbuf struct {
	Csr RegisterCsrType
	Ccr RegisterCcrType
}

// RegisterCsrType VREFBUF control and status register
type RegisterCsrType uint32

func (r *RegisterCsrType) Load() uint32 {
	return volatile.LoadUint32((*uint32)(r))
}

func (r *RegisterCsrType) Store(value uint32) {
	volatile.StoreUint32((*uint32)(r), value)
}

func (r *RegisterCsrType) StoreBits(mask uint32) {
	value := volatile.LoadUint32((*uint32)(r))
	volatile.StoreUint32((*uint32)(r), value|mask)
}

func (r *RegisterCsrType) ClearBits(mask uint32) {
	value := volatile.LoadUint32((*uint32)(r))
	volatile.StoreUint32((*uint32)(r), value&^mask)
}

func (r *RegisterCsrType) HasBits(mask uint32) bool {
	value := volatile.LoadUint32((*uint32)(r))
	return value&mask != 0
}

const (
	RegisterCsrFieldEnvrShift = 0
	RegisterCsrFieldEnvrMask  = 0x1
)

// GetEnvr Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
func (r *RegisterCsrType) GetEnvr() bool {
	return (volatile.LoadUint32((*uint32)(r)) & RegisterCsrFieldEnvrMask) != 0
}

// SetEnvr Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
func (r *RegisterCsrType) SetEnvr(value bool) {
	if value {
		volatile.StoreUint32((*uint32)(r), volatile.LoadUint32((*uint32)(r))|RegisterCsrFieldEnvrMask)
	} else {
		volatile.StoreUint32((*uint32)(r), volatile.LoadUint32((*uint32)(r))&^RegisterCsrFieldEnvrMask)
	}
}

const (
	RegisterCsrFieldHizShift = 1
	RegisterCsrFieldHizMask  = 0x2
)

// GetHiz High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
func (r *RegisterCsrType) GetHiz() bool {
	return (volatile.LoadUint32((*uint32)(r)) & RegisterCsrFieldHizMask) != 0
}

// SetHiz High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
func (r *RegisterCsrType) SetHiz(value bool) {
	if value {
		volatile.StoreUint32((*uint32)(r), volatile.LoadUint32((*uint32)(r))|RegisterCsrFieldHizMask)
	} else {
		volatile.StoreUint32((*uint32)(r), volatile.LoadUint32((*uint32)(r))&^RegisterCsrFieldHizMask)
	}
}

const (
	RegisterCsrFieldVrrShift = 3
	RegisterCsrFieldVrrMask  = 0x8
)

// GetVrr Voltage reference buffer ready
func (r *RegisterCsrType) GetVrr() bool {
	return (volatile.LoadUint32((*uint32)(r)) & RegisterCsrFieldVrrMask) != 0
}

const (
	RegisterCsrFieldVrsShift = 4
	RegisterCsrFieldVrsMask  = 0x70
)

// GetVrs Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
func (r *RegisterCsrType) GetVrs() uint8 {
	return uint8((volatile.LoadUint32((*uint32)(r)) & RegisterCsrFieldVrsMask) >> RegisterCsrFieldVrsShift)
}

// SetVrs Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
func (r *RegisterCsrType) SetVrs(value uint8) {
	volatile.StoreUint32((*uint32)(r), (volatile.LoadUint32((*uint32)(r))&^RegisterCsrFieldVrsMask)|(uint32(value)<<RegisterCsrFieldVrsShift))
}

// RegisterCcrType VREFBUF calibration control register
type RegisterCcrType uint32

func (r *RegisterCcrType) Load() uint32 {
	return volatile.LoadUint32((*uint32)(r))
}

func (r *RegisterCcrType) Store(value uint32) {
	volatile.StoreUint32((*uint32)(r), value)
}

func (r *RegisterCcrType) StoreBits(mask uint32) {
	value := volatile.LoadUint32((*uint32)(r))
	volatile.StoreUint32((*uint32)(r), value|mask)
}

func (r *RegisterCcrType) ClearBits(mask uint32) {
	value := volatile.LoadUint32((*uint32)(r))
	volatile.StoreUint32((*uint32)(r), value&^mask)
}

func (r *RegisterCcrType) HasBits(mask uint32) bool {
	value := volatile.LoadUint32((*uint32)(r))
	return value&mask != 0
}

const (
	RegisterCcrFieldTrimShift = 0
	RegisterCcrFieldTrimMask  = 0x3f
)

// GetTrim Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
func (r *RegisterCcrType) GetTrim() uint8 {
	return uint8((volatile.LoadUint32((*uint32)(r)) & RegisterCcrFieldTrimMask) >> RegisterCcrFieldTrimShift)
}

// SetTrim Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
func (r *RegisterCcrType) SetTrim(value uint8) {
	volatile.StoreUint32((*uint32)(r), (volatile.LoadUint32((*uint32)(r))&^RegisterCcrFieldTrimMask)|(uint32(value)<<RegisterCcrFieldTrimShift))
}
