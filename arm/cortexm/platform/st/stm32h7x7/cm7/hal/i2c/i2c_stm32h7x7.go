package i2c

import (
	"pkg.si-go.dev/chip/arm/cortexm/platform/st/stm32h7x7/cm7/hal/pin"
	"pkg.si-go.dev/chip/arm/cortexm/platform/st/stm32h7x7/cm7/reg/i2c"
	"pkg.si-go.dev/chip/arm/cortexm/platform/st/stm32h7x7/cm7/reg/rcc"
	"pkg.si-go.dev/chip/core/hal"
	. "pkg.si-go.dev/chip/core/hal/pin"
	"sync"
	"time"
	"volatile"
)

type _error int

const (
	errNACK    _error = -1
	errBus     _error = -2
	errTimeout _error = -3

	defaultTimeout = 100 * time.Millisecond
)

func (e _error) Error() string {
	switch e {
	case 0:
		return "i2c: no error"
	case errNACK:
		return "i2c: not acknowledge received"
	case errBus:
		return "i2c: bus error"
	case errTimeout:
		return "i2c: timeout"
	default:
		return "i2c: unknown error"
	}
}

var (
	I2C1 = &_i2c{index: 0}
	I2C2 = &_i2c{index: 1}
	I2C3 = &_i2c{index: 2}
	I2C4 = &_i2c{index: 3}
)

type Config struct {
	ClockFrequency uint32
	ClockPrescaler uint8
	// DataHoldNs     uint8
	// DataRiseNs     uint8
	// DataFallNs     uint8

	// TODO: This is sort of a "magic" value generated by STM32Cube
	Timing uint32

	SDA     pin.Pin
	SCL     pin.Pin
	Enabled bool
	Timeout time.Duration
}

type _i2c struct {
	index          uint8
	address        uint16
	clockFrequency uint32
	timing         uint32
	timeout        time.Duration

	mutex sync.Mutex
}

func altFunction(p pin.Pin, instance *_i2c, wantSCL bool) (pin.Mode, error) {
	if instance == I2C4 {
		if wantSCL {
			switch p {
			case pin.PB6, pin.PB8:
				return pin.Alt6, nil
			case pin.PD2, pin.PF14, pin.PH11:
				return pin.Alt4, nil
			}
		} else {
			switch p {
			case pin.PB7, pin.PB9, pin.PF0, pin.PH5, pin.PH8:
				return pin.Alt6, nil
			case pin.PD13, pin.PF15, pin.PH12:
				return pin.Alt4, nil
			}
		}
	} else {
		if wantSCL {
			switch p {
			case pin.PA8, pin.PB6, pin.PB8, pin.PB10, pin.PF1, pin.PH4, pin.PH7:
				return pin.Alt4, nil
			}
		} else {
			switch p {
			case pin.PB7, pin.PB9, pin.PB11, pin.PC9, pin.PF0, pin.PH5, pin.PH8:
				return pin.Alt4, nil
			}
		}
	}
	return 0, hal.ErrInvalidPinout
}

func (i *_i2c) Configure(config Config) error {
	i.mutex.Lock()
	defer i.mutex.Unlock()

	p := i2c.Instances[i.index]
	i.clockFrequency = config.ClockFrequency
	i.timing = config.Timing

	i.timeout = defaultTimeout
	if config.Timeout != 0 {
		i.timeout = config.Timeout
	}

	// Disable the peripheral and allow time for reset.
	p.Cr1.SetPe(false)
	for p.Cr1.GetPe() {
	}

	// Enable/disable the respective I2C peripheral clock.
	switch i.index {
	case 0:
		rcc.Rcc.Apb1lenr.SetI2c1en(config.Enabled)
	case 1:
		rcc.Rcc.Apb1lenr.SetI2c2en(config.Enabled)
	case 2:
		rcc.Rcc.Apb1lenr.SetI2c3en(config.Enabled)
	case 3:
		rcc.Rcc.Apb4enr.SetI2c4en(config.Enabled)
	default:
		panic("unreachable")
	}

	if !config.Enabled {
		return nil
	}

	// Configure the GPIO pins.
	if alt, err := altFunction(config.SDA, i, false); err != nil {
		return err
	} else {
		config.SDA.SetMode(AltFunction | alt)
	}

	config.SDA.SetOutputMode(pin.OpenDrain)
	config.SDA.SetSpeedMode(pin.HighSpeed)

	if alt, err := altFunction(config.SCL, i, true); err != nil {
		return err
	} else {
		config.SCL.SetMode(pin.AltFunction | alt)
	}

	config.SCL.SetOutputMode(pin.OpenDrain)
	config.SCL.SetSpeedMode(pin.HighSpeed)

	// Set the timings.
	volatile.StoreUint32((*uint32)(&p.Timingr), config.Timing)

	// Enable the peripheral.
	p.Cr1.SetPe(true)
	for !p.Cr1.GetPe() {
	}

	return nil
}

func (i *_i2c) Read(b []byte) (n int, err error) {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	n, err = i.readAddress(i.address, b)
	return n, err
}

func (i *_i2c) Write(b []byte) (n int, err error) {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	n, err = i.writeAddress(i.address, b)
	return n, err
}

func (i *_i2c) SetAddress(addr uint16) {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	i.address = addr
}

func (i *_i2c) SetClockFrequency(clockSpeedHz uint32) bool {
	// i.clockFrequency = clockSpeedHz
	return true
}

func (i *_i2c) GetClockFrequency() uint32 {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	result := i.clockFrequency
	return result
}

func (i *_i2c) SetTiming(clockSpeedHz uint32, timing uint32) {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	p := i2c.Instances[i.index]

	// Disable the peripheral.
	p.Cr1.SetPe(true)

	// Set the new timing value.
	volatile.StoreUint32((*uint32)(&p.Timingr), timing)

	// Enable the peripheral.
	p.Cr1.SetPe(true)

	i.clockFrequency = clockSpeedHz
	i.timing = timing
}

func (i *_i2c) GetTiming() (uint32, uint32) {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	f := i.clockFrequency
	timing := i.timing
	return f, timing
}

func (i *_i2c) WriteAddress(addr uint16, b []byte) (n int, err error) {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	n, err = i.writeAddress(addr, b)
	return n, err
}

func (i *_i2c) ReadAddress(addr uint16, b []byte) (n int, err error) {
	i.mutex.Lock()
	defer i.mutex.Unlock()
	n, err = i.readAddress(addr, b)
	return n, err
}

func (i *_i2c) writeAddress(addr uint16, b []byte) (n int, err error) {
	p := i2c.Instances[i.index]

	p.Cr2.SetAdd10(false) // 7-bit address mode
	p.Cr2.SetRdwrn(false) // Write mode

	totalLen := len(b)
	for n < totalLen {
		remaining := totalLen - n
		var nbytes uint8
		reload := false

		if remaining > 255 {
			nbytes = 255
			reload = true
		} else {
			nbytes = uint8(remaining)
			reload = false
		}

		if nbytes == 0 {
			return n, nil
		}

		// Clear flags.
		p.Icr.SetStopcf(true)
		p.Icr.SetNackcf(true)
		p.Icr.SetBerrcf(true)
		p.Icr.SetOvrcf(true)
		p.Icr.SetArlocf(true)

		// Configure address and byte count.
		p.Cr2.SetSadd(addr)
		p.Cr2.SetNbytes(nbytes)
		p.Cr2.SetReload(reload)
		p.Cr2.SetAutoend(!reload)
		p.Cr2.SetStart(true)

		for nbytes > 0 {
			deadline := time.Now().Add(i.timeout)
			for !p.Isr.GetTxis() {
				if p.Isr.GetNackf() {
					// Clear the NACK flag.
					p.Icr.SetNackcf(true)

					// Wait for STOP
					for !p.Isr.GetStopf() {
						if time.Now().After(deadline) {
							if p.Isr.GetBusy() {
								// Generate a stop.
								p.Cr2.SetStop(true)
								deadline = time.Now().Add(i.timeout)
								for !p.Isr.GetStopf() {
									if time.Now().After(deadline) {
										return n, errTimeout
									}
								}
							}
						}
					}

					// Clear STOP flag.
					p.Icr.SetStopcf(true)
					return n, errNACK
				}

				// Check bus errors.
				if p.Isr.GetBerr() {
					p.Icr.SetBerrcf(true)
					return n, errBus
				}

				if p.Isr.GetOvr() {
					p.Icr.SetOvrcf(true)
					return n, errBus
				}

				if p.Isr.GetArlo() {
					p.Icr.SetArlocf(true)
					return n, errBus
				}

				if time.Now().After(deadline) {
					return n, errTimeout
				}
			}

			// Write the data buffer.
			p.Txdr.SetTxdata(b[n])
			n++
			nbytes--

			if nbytes == 0 {
				deadline = time.Now().Add(i.timeout)
				if reload {
					for !p.Isr.GetTcr() {
						if p.Isr.GetStopf() {
							p.Icr.SetStopcf(true)
							break
						}

						if time.Now().After(deadline) {
							return n, errTimeout
						}
					}
				} else {
					for !p.Isr.GetStopf() {
						if time.Now().After(deadline) {
							return n, errTimeout
						}
					}
					p.Icr.SetStopcf(true)
				}
			}
		}
	}

	return n, nil
}

func (i *_i2c) readAddress(addr uint16, b []byte) (n int, err error) {
	p := i2c.Instances[i.index]

	p.Cr2.SetAdd10(false) // 7-bit address mode
	p.Cr2.SetRdwrn(true)  // Read mode

	totalLen := len(b)
	for n < totalLen {
		remaining := totalLen - n
		var nbytes uint8
		reload := false

		if remaining > 255 {
			nbytes = 255
			reload = true
		} else {
			nbytes = uint8(remaining)
			reload = false
		}

		// Configure address and byte count.
		p.Cr2.SetSadd(addr)
		p.Cr2.SetNbytes(nbytes)
		p.Cr2.SetReload(reload)
		p.Cr2.SetAutoend(!reload)
		p.Cr2.SetStart(true)

		for nbytes > 0 {
			deadline := time.Now().Add(i.timeout)
			for !p.Isr.GetRxne() {
				if p.Isr.GetStopf() {
					p.Icr.SetStopcf(true)
					if p.Isr.GetRxne() {
						break
					}

					if p.Isr.GetNackf() {
						p.Icr.SetNackcf(true)
						return n, errNACK
					}
				}

				// Check bus errors.
				if p.Isr.GetBerr() {
					p.Icr.SetBerrcf(true)
					return n, errBus
				}

				if p.Isr.GetOvr() {
					p.Icr.SetOvrcf(true)
					return n, errBus
				}

				if p.Isr.GetArlo() {
					p.Icr.SetArlocf(true)
					return n, errBus
				}

				if time.Now().After(deadline) {
					return n, errTimeout
				}
			}

			// Read receive buffer.
			b[n] = p.Rxdr.GetRxdata()
			n++
			nbytes--

			if nbytes == 0 && reload {
				deadline := time.Now().Add(i.timeout)
				for !p.Isr.GetTcr() {
					if p.Isr.GetStopf() {
						p.Icr.SetStopcf(true)
						break
					}

					if time.Now().After(deadline) {
						return n, errTimeout
					}
				}
			}
		}
	}

	return
}
